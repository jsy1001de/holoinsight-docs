# 时间解析
支持的 Golang time layout：（注意这是 Golang 格式，并不代表最终时间字符串一定严格长这个样子）
1. Mon Jan _2 15:04:05 MST 2006
2. Mon Jan _2 15:04:05 2006
3. 2006 Jan/02 15:04:05
4. 02/Jan/2006 15:04:05
5. Jan 02 2006 15:04:05
6. 01/02/2006 15:04:05
7. 2006-01-02 15:04:05.000 Z07:00
8. 2006-01-02 15:04:05.000Z07:00
9. 2006-01-02 15:04:05.000
10. 2006-01-02 15:04:05 Z07:00
11. 2006-01-02 15:04:05Z07:00
12. 2006-01-02 15:04:05
13. 2006/01/02 15:04:05.000 Z07:00
14. 2006/01/02 15:04:05.000Z07:00
15. 2006/01/02 15:04:05.000
16. 2006/01/02 15:04:05 Z07:00
17. 2006/01/02 15:04:05Z07:00
18. 2006/01/02 15:04:05
19. 2006-01-02T15:04:05.000 Z07:00
20. 2006-01-02T15:04:05.000Z07:00
21. 2006-01-02T15:04:05.000
22. 2006-01-02T15:04:05 Z07:00
23. 2006-01-02T15:04:05Z07:00
24. 2006-01-02T15:04:05

解析的时候，格式最长的优先进行匹配，后面18种格式其实是3种格式的变种。

- `.000` 可以匹配毫秒部分，比如 "2006-01-02 15:04:05,123" 或 "2006-01-02 15:04:05.123"
- `Z07:00` 可以匹配时区部分，比如 "2006-01-02 15:04:05,123 Z" 或 "2006-01-02 15:04:05,123 +08:00"，Z 表示 UTC 时区

# 时区解析
   容器的日志所属的时区有3个来源，按如下优先级从高到低：
1. 时间字符串里自带时区信息：比如  'Z' '+08:00'
2. 容器环境变量 `TZ`
3. 解析 `/etc/localtime`，按照规范，它必须是一个软链接，链接到 `/usr/share/zoneinfo/Asia/Shanghai` 之类的时区文件 
   1. 在实践中，很多用户并没有让 `/etc/localtime` 成为一个软链接，而是直接将 `/usr/share/zoneinfo/Asia/Shanghai` 复制覆盖了 `/etc/localtime`，因此它是一个普通文件
   2. 在实践中，出现过 `/etc/localtime` 指向 `/usr/share/zoneinfo/UTC`，但 `UTC` 的文件内容竟然是东八区的内容：从文件名看起来是 `UTC`, 但实际是 `CST-8` （东八区），这意味着我们需要解析文件内容才能最终确定时区，但是 zoneinfo 的文件内容只会告诉你该地理时区包含哪几个经度时区，比如 `Asia/Shanghai` 文件会告诉你它包含 `CST-8` （东八区），但是只从文件内容是无法知道它其实是 `Asia/Shanghai` 这个地理时区的。因为 `Asia/Chongqing` 这个时区（可能已经不在用了）也包含 `CST-8`，因此只根据 `CST-8` 不能反推出 `Asia/Shanghai`，虽然在实践中你确实可以这么做，大概率没问题，但面临国外时区时就懵了，因为我们很难去懂外国的时区关系，特别是那些一个国家包含多个时区的
      1. 虽然说无法从 zoneinfo 解析出类似 `Asia/Shanghai` 之类的地理时区名称，但它依旧可以用于正确解析出时间（因为时区名称只是一个名字，它指向一堆时区规则）。因此解析不出 `Asia/Shanghai` 之类的名称根本无所谓，只是看起来明确好看而已，我们能解出 `CST-8` 这个名称已经很大程度解决问题了
   3. 上述提到的两种错误实践其实挺常见的，因此 Agent 对此也做了支持
4.  如果上述手段都不能解出时区，默认使用 UTC 时区

注意，时区的解析只会发生在 Agent 第一次碰到该容器时，在Agent进程的生命周期内只会执行一次。因此通过 k8s 的 postStart 钩子去修改时区这种行为是无效的，因为此时容器已经启动成功了，这种行为也不会影响已经启动的进程对时区的认知。

错误做法：
某个容器直接把 `/etc/localtime` 链接到 zoneinfo 目录，这完全是不符合规范的。此时默认为 UTC 时区。

## 推荐时区配置方式
1. 为容器声明环境变量 `TZ`，比如在 k8s 的 yaml 里就很合适，或者直接在 Dockerfile 里声明 `ENV TZ=Asia/Shanghai`
2. 在 Dockerfile 里将 `/etc/localtime` 软链接到 `/usr/share/zoneinfo/Asia/Shanghai`
   `RUN ln -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime`
